CCS PCH C Compiler, Version 4.081, 42502               08-Feb-11 17:07

               Filename: E:\sd-spring2011\headband_edge_triggered\code\main.lst

               ROM used: 5526 bytes (17%)
                         Largest free fragment is 27238
               RAM used: 144 (9%) at main() level
                         201 (13%) worst case
               Stack:    5 worst case (3 in main + 2 for interrupts)

*
0000:  GOTO   13E0
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF2.5
004E:  GOTO   0058
0052:  BTFSC  FF2.2
0054:  GOTO   0530
0058:  BTFSS  F9D.1
005A:  GOTO   0064
005E:  BTFSC  F9E.1
0060:  GOTO   020C
0064:  BTFSS  FF2.4
0066:  GOTO   0070
006A:  BTFSC  FF2.1
006C:  GOTO   011A
0070:  BTFSS  FA3.0
0072:  GOTO   007C
0076:  BTFSC  FA4.0
0078:  GOTO   040A
007C:  MOVFF  0F,00
0080:  MOVFF  10,01
0084:  MOVFF  11,02
0088:  MOVFF  12,03
008C:  MOVFF  13,04
0090:  BSF    0E.7
0092:  MOVFF  0D,FE9
0096:  MOVFF  08,FEA
009A:  MOVFF  09,FE1
009E:  MOVFF  0A,FE2
00A2:  MOVFF  0B,FD9
00A6:  MOVFF  0C,FDA
00AA:  MOVFF  14,FF3
00AE:  MOVFF  15,FF4
00B2:  MOVFF  16,FFA
00B6:  MOVF   05,W
00B8:  MOVFF  07,FE0
00BC:  MOVFF  06,FD8
00C0:  RETFIE 0
.................... #include "main.h" 
.................... #include <18F2580.h> 
.................... //////// Standard Header file for the PIC18F2580 device //////////////// 
.................... #device PIC18F2580 
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                      //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES BBSIZ2K                  //2K words Boot Block size 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=20000000) 
*
07B4:  CLRF   FEA
07B6:  MOVLW  8D
07B8:  MOVWF  FE9
07BA:  MOVF   FEF,W
07BC:  BZ    07D8
07BE:  MOVLW  06
07C0:  MOVWF  01
07C2:  CLRF   00
07C4:  DECFSZ 00,F
07C6:  BRA    07C4
07C8:  DECFSZ 01,F
07CA:  BRA    07C2
07CC:  MOVLW  7B
07CE:  MOVWF  00
07D0:  DECFSZ 00,F
07D2:  BRA    07D0
07D4:  DECFSZ FEF,F
07D6:  BRA    07BE
07D8:  RETLW  00
.................... #use rs232(baud=57600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8, stream=USB) 
....................  
.................... // PIC pin defines 
.................... #define GREEN PIN_A0 
.................... #define YELLOW PIN_C2 
.................... #define RED PIN_A1 
.................... #define CAN_RS pin_c5 
....................  
.................... // CANbus baud rate settings, all are CCS PICC defaults except CAN_BRG_PRESCALAR 
.................... #define CAN_USE_EXTENDED_ID FALSE 
.................... #define CAN_BRG_PRESCALAR  9 // THIS ONE SETS CAN BAUD RATE TO 62500 kbps!  
....................  
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
.................... 	int1 void0; //0 
.................... 	CAN_WIN_ADDRESS win:3;	//1:3 //window address bits 
.................... 	int1 abat;	//4 //abort all pending transmissions 
.................... 	CAN_OP_MODE reqop:3;	//5:7	//request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = 0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
.................... 	int1 void0;	//0 
.................... 	CAN_INT_CODE icode:3;	//1:3	//interrupt code 
.................... 	int1 void4;	//4 
.................... 	CAN_OP_MODE opmode:3;	//5:7	//operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = 0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
.................... 	int1 ewarn;		//0 //error warning 
.................... 	int1 rxwarn;		//1 //receiver warning 
.................... 	int1 txwarn;		//2 //transmitter warning 
.................... 	int1 rxbp;	//3 //receiver bus passive 
.................... 	int1 txbp;	//4 //transmitter bus passive bit 
.................... 	int1 txbo;	//5	//transmitter bus off 
.................... 	int1 rx1ovfl;	//6	//receive buffer 1 overflow 
.................... 	int1 rx0ovfl;	//7	//receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT=0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
.................... 	int brp:6;	//0:5	//baud rate prescalar 
.................... 	int sjw:2;	//6:7	//synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1=0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
.................... 	int prseg:3; //0:2 //propagation time select 
.................... 	int seg1ph:3; //3:5 //phase segment 1 
.................... 	int1 sam; //6 //sample of the can bus line 
.................... 	int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2=0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
.................... 	int seg2ph:3;	//0:2	//phase segment 2 time select 
.................... 	int void543:3;	//3:5 
.................... 	int1 wakfil;	//6 //selects can bus line filter for wake-up 
.................... 	int1 void7;	//7 
.................... } BRGCON3; 
.................... #byte BRGCON3=0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
.................... 	int void3210:4;	//0:3 
.................... 	int1 cancap;	//4 //can message receive caputre 
.................... 	int1 endrhi;	//5 //enable drive high 
.................... 	int void76:2;	//6:7 
.................... } CIOCON; 
.................... #byte CIOCON=0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
.................... 	int  txpri:2;	//0:1	//transmit priority bits 
.................... 	int1 void2; //2 
.................... 	int1 txreq;	//3	//transmit request status (clear to request message abort) 
.................... 	int1 txerr;	//4	//transmission error detected 
.................... 	int1 txlarb;	//5	//transmission lost arbitration status 
.................... 	int1 txabt;	//6	//transmission aborted status 
.................... 	int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte	TXB0CON=0xF40 
.................... #byte	TXB1CON=0xF30 
.................... #byte	TXB2CON=0xF20 
.................... #byte TXBaCON=0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH=0xF41 
.................... #byte TXB0SIDL=0xF42 
.................... #byte TXB1SIDH=0xF31 
.................... #byte TXB1SIDL=0xF32 
.................... #byte TXB2SIDH=0xF21 
.................... #byte TXB2SIDL=0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH=0xF43 
.................... #byte TXB0EIDL=0xF44 
.................... #byte TXB1EIDH=0xF33 
.................... #byte TXB1EIDL=0xF34 
.................... #byte TXB2EIDH=0xF23 
.................... #byte TXB2EIDL=0xF24 
....................  
.................... #define RX0MASK      0xF1B    //rxm0eidl 
.................... #define RX1MASK      0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   0xF03    //rxf0eidl 
.................... #define RX0FILTER1   0xF07    //rxf1eidl 
.................... #define RX1FILTER2   0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   0xF13    //rxf4eidl 
.................... #define RX1FILTER5   0xF17    //rxf5eidl 
.................... #define RXB0ID       0xF64    //rxb0eidl 
.................... #define RXB1ID       0xF54    //rxb1eidl 
.................... #define TXB0ID       0xF44    //txb0eidl 
.................... #define TXB1ID       0xF34    //txb1eidl 
.................... #define TXB2ID       0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0=0xF46 
.................... #byte TXB0D7=0xF4D 
.................... #byte TXB1D0=0xF36 
.................... #byte TXB1D7=0xF3D 
.................... #byte TXB2D0=0xF26 
.................... #byte TXB2D7=0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
.................... 	int dlc:4;	//0:3 
.................... 	int void54:2; //4:5 
.................... 	int1 rtr; //6 //transmission frame remote tranmission 
.................... 	int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC=0xF45 
.................... #byte TXB1DLC=0xF35 
.................... #byte TXB2DLC=0xF25 
.................... #byte TXBaDLC=0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
.................... 	int1 filthit0;	//0 //filter hit 
.................... 	int1 jtoff;	//1 //jump table offset 
.................... 	int1 rxb0dben;	//2 //receive buffer 0 double buffer enable 
.................... 	int1 rxrtrro;	//3 //receive remote transfer request 
.................... 	int1 void4;	//4 
.................... 	CAN_RX_MODE rxm:2;	//5:6 //receiver buffer mode 
.................... 	int1 rxful;	//7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON=0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
.................... 	int filthit:3;	//0:2 
.................... 	int1 rxrtrro;	//3 //receive remote transfer request 
.................... 	int1 void4;	//4 
.................... 	CAN_RX_MODE rxm:2;	//5:6 //receive buffer mode 
.................... 	int1 rxful;	//7	//receive full 
.................... } RXB1CON; 
.................... #byte	RXB1CON=0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte	RXB0SIDH=0xF61 
.................... #byte	RXB0SIDL=0xF62 
.................... #byte	RXB1SIDH=0xF51 
.................... #byte	RXB1SIDL=0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte	RXB0EIDH=0xF63 
.................... #byte	RXB0EIDL=0xF64 
.................... #byte	RXB1EIDH=0xF53 
.................... #byte	RXB1EIDL=0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
.................... 	int dlc:4;	//0:3 //data length code 
.................... 	int1 rb0; //4 //reserved 
.................... 	int1 rb1;	//5 //reserved 
.................... 	int1 rtr;	//6 //receiver remote transmission request bit 
.................... 	int1 void7;	//7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte	RXB0DLC=0xF65 
.................... #byte	RXB1DLC=0xF55 
.................... #byte	RXBaDLC=0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0=0xF66 
.................... #byte RXB0D7=0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT=0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH=0xF00 
.................... #byte RXF0SIDL=0xF01 
.................... #byte RXF1SIDH=0xF04 
.................... #byte RXF1SIDL=0xF05 
.................... #byte RXF2SIDH=0xF08 
.................... #byte RXF2SIDL=0xF09 
.................... #byte RXF3SIDH=0xF0C 
.................... #byte RXF3SIDL=0xF0D 
.................... #byte RXF4SIDH=0xF10 
.................... #byte RXF4SIDL=0xF11 
.................... #byte RXF5SIDH=0xF14 
.................... #byte RXF5SIDL=0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH=0xF02 
.................... #byte RXF0EIDL=0xF03 
.................... #byte RXF1EIDH=0xF06 
.................... #byte RXF1EIDL=0xF07 
.................... #byte RXF2EIDH=0xF0A 
.................... #byte RXF2EIDL=0xF0B 
.................... #byte RXF3EIDH=0xF0E 
.................... #byte RXF3EIDL=0xF0F 
.................... #byte RXF4EIDH=0xF12 
.................... #byte RXF4EIDL=0xF13 
.................... #byte RXF5EIDH=0xF16 
.................... #byte RXF5EIDL=0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH=0xF18 
.................... #byte RXM0SIDL=0xF19 
.................... #byte RXM1SIDH=0xF1C 
.................... #byte RXM1SIDL=0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH=0xF1A 
.................... #byte RXM0EIDL=0xF1B 
.................... #byte RXM1EIDH=0xF1E 
.................... #byte RXM1EIDL=0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = 0xFA4.7 
.................... #bit CAN_INT_WAKIF = 0xFA4.6 
.................... #bit CAN_INT_ERRIF = 0xFA4.5 
.................... #bit CAN_INT_TXB2IF = 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(int* addr, int32 id, int1 ext); 
.................... int32 can_get_id(int * addr, int1 ext); 
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
06EC:  MOVLW  04
06EE:  MOVWF  x8C
06F0:  RCALL  056A
....................    can_set_baud(); 
06F2:  BRA    058C
....................  
....................    RXB0CON=0; 
06F4:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
06F6:  MOVLW  9F
06F8:  ANDWF  F60,W
06FA:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
06FC:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
06FE:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
0702:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
0704:  BCF    F73.4
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
0706:  MOVLW  0F
0708:  MOVWF  x9B
070A:  MOVLW  1B
070C:  MOVWF  x9A
070E:  CLRF   x9F
0710:  CLRF   x9E
0712:  CLRF   x9D
0714:  CLRF   x9C
0716:  CLRF   xA0
0718:  RCALL  05BC
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
071A:  MOVLW  0F
071C:  MOVWF  x9B
071E:  MOVLW  03
0720:  MOVWF  x9A
0722:  CLRF   x9F
0724:  CLRF   x9E
0726:  CLRF   x9D
0728:  CLRF   x9C
072A:  CLRF   xA0
072C:  RCALL  05BC
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
072E:  MOVLW  0F
0730:  MOVWF  x9B
0732:  MOVLW  07
0734:  MOVWF  x9A
0736:  CLRF   x9F
0738:  CLRF   x9E
073A:  CLRF   x9D
073C:  CLRF   x9C
073E:  CLRF   xA0
0740:  RCALL  05BC
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
0742:  MOVLW  0F
0744:  MOVWF  x9B
0746:  MOVLW  1F
0748:  MOVWF  x9A
074A:  CLRF   x9F
074C:  CLRF   x9E
074E:  CLRF   x9D
0750:  CLRF   x9C
0752:  CLRF   xA0
0754:  RCALL  05BC
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
0756:  MOVLW  0F
0758:  MOVWF  x9B
075A:  MOVLW  0B
075C:  MOVWF  x9A
075E:  CLRF   x9F
0760:  CLRF   x9E
0762:  CLRF   x9D
0764:  CLRF   x9C
0766:  CLRF   xA0
0768:  RCALL  05BC
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
076A:  MOVLW  0F
076C:  MOVWF  x9B
076E:  MOVWF  x9A
0770:  CLRF   x9F
0772:  CLRF   x9E
0774:  CLRF   x9D
0776:  CLRF   x9C
0778:  CLRF   xA0
077A:  RCALL  05BC
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
077C:  MOVLW  0F
077E:  MOVWF  x9B
0780:  MOVLW  13
0782:  MOVWF  x9A
0784:  CLRF   x9F
0786:  CLRF   x9E
0788:  CLRF   x9D
078A:  CLRF   x9C
078C:  CLRF   xA0
078E:  RCALL  05BC
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
0790:  MOVLW  0F
0792:  MOVWF  x9B
0794:  MOVLW  17
0796:  MOVWF  x9A
0798:  CLRF   x9F
079A:  CLRF   x9E
079C:  CLRF   x9D
079E:  CLRF   x9C
07A0:  CLRF   xA0
07A2:  RCALL  05BC
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
07A4:  MOVF   F93,W
07A6:  ANDLW  FB
07A8:  IORLW  08
07AA:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
07AC:  CLRF   x8C
07AE:  RCALL  056A
.................... } 
07B0:  GOTO   07E4 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
058C:  MOVLW  C0
058E:  ANDWF  F70,W
0590:  IORLW  09
0592:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
0594:  MOVLW  3F
0596:  ANDWF  F70,W
0598:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
059A:  MOVLW  F8
059C:  ANDWF  F71,W
059E:  IORLW  02
05A0:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
05A2:  MOVLW  C7
05A4:  ANDWF  F71,W
05A6:  IORLW  28
05A8:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
05AA:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
05AC:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
05AE:  MOVLW  F8
05B0:  ANDWF  F72,W
05B2:  IORLW  05
05B4:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
05B6:  BCF    F72.6
.................... } 
05B8:  GOTO   06F4 (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
056A:  SWAPF  x8C,W
056C:  ANDLW  70
056E:  MOVWF  00
0570:  BCF    FD8.0
0572:  RLCF   00,F
0574:  MOVLW  1F
0576:  ANDWF  F6F,W
0578:  IORWF  00,W
057A:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
057C:  MOVFF  F6E,00
0580:  SWAPF  00,F
0582:  RRCF   00,W
0584:  ANDLW  07
0586:  SUBWF  x8C,W
0588:  BNZ   057C
.................... } 
058A:  RETLW  00
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(int* addr, int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
05BC:  MOVFF  9B,A2
05C0:  MOVFF  9A,A1
....................  
....................    if (ext) {  //extended 
05C4:  MOVF   xA0,F
05C6:  BZ    066C
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
05C8:  MOVFF  A1,FE9
05CC:  MOVFF  A2,FEA
05D0:  MOVFF  9C,FEF
....................  
....................       //eidh 
....................       ptr--; 
05D4:  MOVF   xA1,W
05D6:  BTFSC  FD8.2
05D8:  DECF   xA2,F
05DA:  DECF   xA1,F
....................       *ptr=make8(id,1); //8:15 
05DC:  MOVFF  A1,FE9
05E0:  MOVFF  A2,FEA
05E4:  MOVFF  9D,FEF
....................  
....................       //sidl 
....................       ptr--; 
05E8:  MOVF   xA1,W
05EA:  BTFSC  FD8.2
05EC:  DECF   xA2,F
05EE:  DECF   xA1,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
05F0:  MOVFF  A1,FE9
05F4:  MOVFF  A2,FEA
05F8:  MOVF   x9E,W
05FA:  ANDLW  03
05FC:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
05FE:  MOVFF  A1,FE9
0602:  MOVFF  A2,FEA
0606:  MOVFF  9E,00
060A:  RLCF   00,F
060C:  RLCF   00,F
060E:  RLCF   00,F
0610:  MOVLW  F8
0612:  ANDWF  00,F
0614:  MOVF   00,W
0616:  ANDLW  E0
0618:  IORWF  FEF,W
061A:  MOVWF  FEF
....................       *ptr|=0x08; 
061C:  MOVFF  A1,FE9
0620:  MOVFF  A2,FEA
0624:  MOVF   FEF,W
0626:  IORLW  08
0628:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
062A:  MOVF   xA1,W
062C:  BTFSC  FD8.2
062E:  DECF   xA2,F
0630:  DECF   xA1,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
0632:  MOVFF  A1,FE9
0636:  MOVFF  A2,FEA
063A:  MOVFF  9E,00
063E:  SWAPF  00,F
0640:  RRCF   00,F
0642:  MOVLW  07
0644:  ANDWF  00,F
0646:  MOVF   00,W
0648:  ANDLW  07
064A:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
064C:  MOVFF  A1,FE9
0650:  MOVFF  A2,FEA
0654:  MOVFF  9F,00
0658:  RLCF   00,F
065A:  RLCF   00,F
065C:  RLCF   00,F
065E:  MOVLW  F8
0660:  ANDWF  00,F
0662:  MOVF   00,W
0664:  ANDLW  F8
0666:  IORWF  FEF,W
0668:  MOVWF  FEF
....................    } 
....................    else {   //standard 
066A:  BRA    06EA
....................       //eidl 
....................       *ptr=0; 
066C:  MOVFF  A1,FE9
0670:  MOVFF  A2,FEA
0674:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
0676:  MOVF   xA1,W
0678:  BTFSC  FD8.2
067A:  DECF   xA2,F
067C:  DECF   xA1,F
....................       *ptr=0; 
067E:  MOVFF  A1,FE9
0682:  MOVFF  A2,FEA
0686:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
0688:  MOVF   xA1,W
068A:  BTFSC  FD8.2
068C:  DECF   xA2,F
068E:  DECF   xA1,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
0690:  MOVFF  A1,FE9
0694:  MOVFF  A2,FEA
0698:  MOVFF  9C,00
069C:  SWAPF  00,F
069E:  RLCF   00,F
06A0:  MOVLW  E0
06A2:  ANDWF  00,F
06A4:  MOVF   00,W
06A6:  ANDLW  E0
06A8:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
06AA:  MOVF   xA1,W
06AC:  BTFSC  FD8.2
06AE:  DECF   xA2,F
06B0:  DECF   xA1,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
06B2:  MOVFF  A1,FE9
06B6:  MOVFF  A2,FEA
06BA:  MOVFF  9C,00
06BE:  RRCF   00,F
06C0:  RRCF   00,F
06C2:  RRCF   00,F
06C4:  MOVLW  1F
06C6:  ANDWF  00,F
06C8:  MOVF   00,W
06CA:  ANDLW  1F
06CC:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
06CE:  MOVFF  A1,FE9
06D2:  MOVFF  A2,FEA
06D6:  MOVFF  9D,00
06DA:  SWAPF  00,F
06DC:  RLCF   00,F
06DE:  MOVLW  E0
06E0:  ANDWF  00,F
06E2:  MOVF   00,W
06E4:  ANDLW  E0
06E6:  IORWF  FEF,W
06E8:  MOVWF  FEF
....................    } 
.................... } 
06EA:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int32 can_get_id(int * addr, int1 ext) { 
....................    int32 ret; 
....................    int * ptr; 
....................  
....................    ret=0; 
*
022C:  CLRF   xBD
022E:  CLRF   xBC
0230:  CLRF   xBB
0232:  CLRF   xBA
....................    ptr=addr; 
0234:  MOVFF  B8,BF
0238:  MOVFF  B7,BE
....................  
....................    if (ext) { 
023C:  MOVF   xB9,F
023E:  BTFSC  FD8.2
0240:  BRA    0358
....................       ret=*ptr;  //eidl 
0242:  MOVFF  BF,03
0246:  MOVFF  BE,FE9
024A:  MOVFF  BF,FEA
024E:  MOVFF  FEF,00
0252:  CLRF   01
0254:  CLRF   02
0256:  CLRF   03
0258:  MOVFF  03,BD
025C:  MOVFF  02,BC
0260:  MOVFF  01,BB
0264:  MOVFF  00,BA
....................  
....................       ptr--;     //eidh 
0268:  MOVF   xBE,W
026A:  BTFSC  FD8.2
026C:  DECF   xBF,F
026E:  DECF   xBE,F
....................       ret|=((int32)*ptr << 8); 
0270:  MOVFF  BE,FE9
0274:  MOVFF  BF,FEA
0278:  MOVF   FEF,W
027A:  CLRF   xC2
027C:  CLRF   xC1
027E:  MOVWF  xC0
0280:  CLRF   00
0282:  MOVF   00,W
0284:  IORWF  xBA,F
0286:  MOVF   xC0,W
0288:  IORWF  xBB,F
028A:  MOVF   xC1,W
028C:  IORWF  xBC,F
028E:  MOVF   xC2,W
0290:  IORWF  xBD,F
....................  
....................       ptr--;     //sidl 
0292:  MOVF   xBE,W
0294:  BTFSC  FD8.2
0296:  DECF   xBF,F
0298:  DECF   xBE,F
....................       ret|=((int32)*ptr & 0x03) << 16; 
029A:  MOVFF  BE,FE9
029E:  MOVFF  BF,FEA
02A2:  MOVF   FEF,W
02A4:  ANDLW  03
02A6:  MOVWF  xC4
02A8:  CLRF   xC5
02AA:  CLRF   xC6
02AC:  CLRF   xC7
02AE:  CLRF   00
02B0:  CLRF   01
02B2:  MOVF   00,W
02B4:  IORWF  xBA,F
02B6:  MOVF   01,W
02B8:  IORWF  xBB,F
02BA:  MOVF   xC4,W
02BC:  IORWF  xBC,F
02BE:  MOVF   xC5,W
02C0:  IORWF  xBD,F
....................       ret|=((int32)*ptr & 0xE0) << 13; 
02C2:  MOVFF  BE,FE9
02C6:  MOVFF  BF,FEA
02CA:  MOVF   FEF,W
02CC:  ANDLW  E0
02CE:  MOVWF  xC4
02D0:  CLRF   xC5
02D2:  CLRF   xC6
02D4:  CLRF   xC7
02D6:  CLRF   00
02D8:  RLCF   xC4,W
02DA:  MOVWF  01
02DC:  RLCF   xC5,W
02DE:  MOVWF  02
02E0:  RLCF   xC6,W
02E2:  MOVWF  03
02E4:  RLCF   01,F
02E6:  RLCF   02,F
02E8:  RLCF   03,F
02EA:  RLCF   01,F
02EC:  RLCF   02,F
02EE:  RLCF   03,F
02F0:  RLCF   01,F
02F2:  RLCF   02,F
02F4:  RLCF   03,F
02F6:  RLCF   01,F
02F8:  RLCF   02,F
02FA:  RLCF   03,F
02FC:  MOVLW  E0
02FE:  ANDWF  01,F
0300:  MOVF   00,W
0302:  IORWF  xBA,F
0304:  MOVF   01,W
0306:  IORWF  xBB,F
0308:  MOVF   02,W
030A:  IORWF  xBC,F
030C:  MOVF   03,W
030E:  IORWF  xBD,F
....................  
....................       ptr--;     //sidh 
0310:  MOVF   xBE,W
0312:  BTFSC  FD8.2
0314:  DECF   xBF,F
0316:  DECF   xBE,F
....................       ret|=((int32)*ptr << 21); 
0318:  MOVFF  BE,FE9
031C:  MOVFF  BF,FEA
0320:  MOVF   FEF,W
0322:  CLRF   xC1
0324:  MOVWF  xC0
0326:  CLRF   00
0328:  CLRF   01
032A:  RLCF   xC0,W
032C:  MOVWF  02
032E:  RLCF   xC1,W
0330:  MOVWF  03
0332:  RLCF   02,F
0334:  RLCF   03,F
0336:  RLCF   02,F
0338:  RLCF   03,F
033A:  RLCF   02,F
033C:  RLCF   03,F
033E:  RLCF   02,F
0340:  RLCF   03,F
0342:  MOVLW  E0
0344:  ANDWF  02,F
0346:  MOVF   00,W
0348:  IORWF  xBA,F
034A:  MOVF   01,W
034C:  IORWF  xBB,F
034E:  MOVF   02,W
0350:  IORWF  xBC,F
0352:  MOVF   03,W
0354:  IORWF  xBD,F
....................  
....................    } 
....................    else { 
0356:  BRA    03F6
....................       ptr-=2;    //sidl 
0358:  MOVLW  02
035A:  SUBWF  xBE,F
035C:  MOVLW  00
035E:  SUBWFB xBF,F
....................       ret=((int32)*ptr & 0xE0) >> 5; 
0360:  MOVFF  BE,FE9
0364:  MOVFF  BF,FEA
0368:  MOVF   FEF,W
036A:  ANDLW  E0
036C:  MOVWF  xC4
036E:  CLRF   xC5
0370:  CLRF   xC6
0372:  CLRF   xC7
0374:  RRCF   xC7,W
0376:  MOVWF  xBD
0378:  RRCF   xC6,W
037A:  MOVWF  xBC
037C:  RRCF   xC5,W
037E:  MOVWF  xBB
0380:  RRCF   xC4,W
0382:  MOVWF  xBA
0384:  RRCF   xBD,F
0386:  RRCF   xBC,F
0388:  RRCF   xBB,F
038A:  RRCF   xBA,F
038C:  RRCF   xBD,F
038E:  RRCF   xBC,F
0390:  RRCF   xBB,F
0392:  RRCF   xBA,F
0394:  RRCF   xBD,F
0396:  RRCF   xBC,F
0398:  RRCF   xBB,F
039A:  RRCF   xBA,F
039C:  RRCF   xBD,F
039E:  RRCF   xBC,F
03A0:  RRCF   xBB,F
03A2:  RRCF   xBA,F
03A4:  MOVLW  07
03A6:  ANDWF  xBD,F
....................  
....................       ptr--;     //sidh 
03A8:  MOVF   xBE,W
03AA:  BTFSC  FD8.2
03AC:  DECF   xBF,F
03AE:  DECF   xBE,F
....................       ret|=((int32)*ptr << 3); 
03B0:  MOVFF  BE,FE9
03B4:  MOVFF  BF,FEA
03B8:  MOVF   FEF,W
03BA:  CLRF   xC3
03BC:  CLRF   xC2
03BE:  CLRF   xC1
03C0:  MOVWF  xC0
03C2:  RLCF   xC0,W
03C4:  MOVWF  00
03C6:  RLCF   xC1,W
03C8:  MOVWF  01
03CA:  RLCF   xC2,W
03CC:  MOVWF  02
03CE:  RLCF   xC3,W
03D0:  MOVWF  03
03D2:  RLCF   00,F
03D4:  RLCF   01,F
03D6:  RLCF   02,F
03D8:  RLCF   03,F
03DA:  RLCF   00,F
03DC:  RLCF   01,F
03DE:  RLCF   02,F
03E0:  RLCF   03,F
03E2:  MOVLW  F8
03E4:  ANDWF  00,F
03E6:  MOVF   00,W
03E8:  IORWF  xBA,F
03EA:  MOVF   01,W
03EC:  IORWF  xBB,F
03EE:  MOVF   02,W
03F0:  IORWF  xBC,F
03F2:  MOVF   03,W
03F4:  IORWF  xBD,F
....................    } 
....................  
....................    return(ret); 
03F6:  MOVFF  BA,00
03FA:  MOVFF  BB,01
03FE:  MOVFF  BC,02
0402:  MOVFF  BD,03
.................... } 
0406:  GOTO   04AA (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) { 
....................    int i; 
....................    int * txd0; 
....................    int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
08C4:  MOVLW  0F
08C6:  MOVWF  x98
08C8:  MOVLW  66
08CA:  MOVWF  x97
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
08CC:  MOVLB  F
08CE:  BTFSC  x40.3
08D0:  BRA    08E2
....................       CANCON.win=CAN_WIN_TX0; 
08D2:  MOVLW  F1
08D4:  ANDWF  F6F,W
08D6:  IORLW  08
08D8:  MOVWF  F6F
....................       port=0; 
08DA:  MOVLB  0
08DC:  CLRF   x99
....................    } 
....................    else if (!TXB1CON.txreq) { 
08DE:  BRA    0916
08E0:  MOVLB  F
08E2:  BTFSC  x30.3
08E4:  BRA    08F8
....................       CANCON.win=CAN_WIN_TX1; 
08E6:  MOVLW  F1
08E8:  ANDWF  F6F,W
08EA:  IORLW  06
08EC:  MOVWF  F6F
....................       port=1; 
08EE:  MOVLW  01
08F0:  MOVLB  0
08F2:  MOVWF  x99
....................    } 
....................    else if (!TXB2CON.txreq) { 
08F4:  BRA    0916
08F6:  MOVLB  F
08F8:  BTFSC  x20.3
08FA:  BRA    090E
....................       CANCON.win=CAN_WIN_TX2; 
08FC:  MOVLW  F1
08FE:  ANDWF  F6F,W
0900:  IORLW  04
0902:  MOVWF  F6F
....................       port=2; 
0904:  MOVLW  02
0906:  MOVLB  0
0908:  MOVWF  x99
....................    } 
....................    else { 
090A:  BRA    0916
090C:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
090E:  MOVLW  00
0910:  MOVWF  01
0912:  BRA    098A
0914:  MOVLB  0
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
0916:  MOVF   x93,W
0918:  ANDLW  03
091A:  MOVWF  00
091C:  MOVLW  FC
091E:  ANDWF  F60,W
0920:  IORWF  00,W
0922:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
0924:  MOVLW  0F
0926:  MOVWF  x9B
0928:  MOVLW  64
092A:  MOVWF  x9A
092C:  MOVFF  8F,9F
0930:  MOVFF  8E,9E
0934:  MOVFF  8D,9D
0938:  MOVFF  8C,9C
093C:  MOVFF  94,A0
0940:  RCALL  05BC
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
0942:  MOVFF  92,F65
....................    TXBaDLC.rtr=rtr; 
0946:  BCF    F65.6
0948:  BTFSC  x95.0
094A:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
094C:  CLRF   x96
094E:  MOVF   x92,W
0950:  SUBWF  x96,W
0952:  BC    097C
....................       *txd0=*data; 
0954:  MOVFF  90,FE9
0958:  MOVFF  91,FEA
095C:  MOVFF  FEF,9C
0960:  MOVFF  98,FEA
0964:  MOVFF  97,FE9
0968:  MOVFF  9C,FEF
....................       txd0++; 
096C:  INCF   x97,F
096E:  BTFSC  FD8.2
0970:  INCF   x98,F
....................       data++; 
0972:  INCF   x90,F
0974:  BTFSC  FD8.2
0976:  INCF   x91,F
....................     } 
0978:  INCF   x96,F
097A:  BRA    094E
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
097C:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
097E:  MOVLW  F1
0980:  ANDWF  F6F,W
0982:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
0984:  MOVLW  01
0986:  MOVWF  01
0988:  MOVLB  F
.................... } 
098A:  MOVLB  0
098C:  GOTO   1448 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat) 
.................... { 
....................     int i; 
....................     int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
0410:  BTFSS  F60.7
0412:  BRA    0442
....................         CANCON.win=CAN_WIN_RX0; 
0414:  MOVLW  F1
0416:  ANDWF  F6F,W
0418:  MOVWF  F6F
....................         stat.buffer=0; 
041A:  BCF    x6D.4
....................  
....................         CAN_INT_RXB0IF=0; 
041C:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
041E:  BCF    x6D.0
0420:  BTFSC  F74.7
0422:  BSF    x6D.0
....................         COMSTAT.rx0ovfl=0; 
0424:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
0426:  BTFSS  F60.2
0428:  BRA    0440
....................          stat.filthit=RXB0CON.filthit0; 
042A:  MOVLW  00
042C:  BTFSC  F60.0
042E:  MOVLW  01
0430:  ANDLW  07
0432:  MOVWF  00
0434:  BCF    FD8.0
0436:  RLCF   00,F
0438:  MOVLW  F1
043A:  ANDWF  x6D,W
043C:  IORWF  00,W
043E:  MOVWF  x6D
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
0440:  BRA    0482
0442:  MOVLB  F
0444:  BTFSS  x50.7
0446:  BRA    047A
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
0448:  MOVLW  F1
044A:  ANDWF  F6F,W
044C:  IORLW  0A
044E:  MOVWF  F6F
....................         stat.buffer=1; 
0450:  MOVLB  0
0452:  BSF    x6D.4
....................  
....................         CAN_INT_RXB1IF=0; 
0454:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
0456:  BCF    x6D.0
0458:  BTFSC  F74.6
045A:  BSF    x6D.0
....................         COMSTAT.rx1ovfl=0; 
045C:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
045E:  MOVLB  F
0460:  MOVF   x50,W
0462:  ANDLW  07
0464:  ANDLW  07
0466:  MOVWF  00
0468:  BCF    FD8.0
046A:  RLCF   00,F
046C:  MOVLW  F1
046E:  MOVLB  0
0470:  ANDWF  x6D,W
0472:  IORWF  00,W
0474:  MOVWF  x6D
....................     } 
....................     else { 
0476:  BRA    0482
0478:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
047A:  MOVLW  00
047C:  MOVWF  01
047E:  BRA    0514
0480:  MOVLB  0
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
0482:  MOVF   F65,W
0484:  ANDLW  0F
0486:  MOVWF  x68
....................     stat.rtr=RXBaDLC.rtr; 
0488:  BCF    x6D.5
048A:  BTFSC  F65.6
048C:  BSF    x6D.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
048E:  BCF    x6D.6
0490:  BTFSC  F62.3
0492:  BSF    x6D.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
0494:  MOVLW  00
0496:  BTFSC  x6D.6
0498:  MOVLW  01
049A:  MOVWF  xB0
049C:  MOVLW  0F
049E:  MOVWF  xB8
04A0:  MOVLW  64
04A2:  MOVWF  xB7
04A4:  MOVFF  B0,B9
04A8:  BRA    022C
04AA:  MOVFF  03,6C
04AE:  MOVFF  02,6B
04B2:  MOVFF  01,6A
04B6:  MOVFF  00,69
....................  
....................     ptr = &TXRXBaD0; 
04BA:  MOVLW  0F
04BC:  MOVWF  xAF
04BE:  MOVLW  66
04C0:  MOVWF  xAE
....................     for ( i = 0; i < len; i++ ) { 
04C2:  CLRF   xAD
04C4:  MOVF   x68,W
04C6:  SUBWF  xAD,W
04C8:  BC    04F2
....................         *data = *ptr; 
04CA:  MOVFF  AE,FE9
04CE:  MOVFF  AF,FEA
04D2:  MOVFF  FEF,B2
04D6:  MOVFF  AC,FEA
04DA:  MOVFF  AB,FE9
04DE:  MOVFF  B2,FEF
....................         data++; 
04E2:  INCF   xAB,F
04E4:  BTFSC  FD8.2
04E6:  INCF   xAC,F
....................         ptr++; 
04E8:  INCF   xAE,F
04EA:  BTFSC  FD8.2
04EC:  INCF   xAF,F
....................     } 
04EE:  INCF   xAD,F
04F0:  BRA    04C4
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
04F2:  MOVLW  F1
04F4:  ANDWF  F6F,W
04F6:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
04F8:  BCF    x6D.7
04FA:  BTFSC  FA4.7
04FC:  BSF    x6D.7
....................     CAN_INT_IRXIF = 0; 
04FE:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
0500:  BTFSS  x6D.4
0502:  BRA    050C
....................       RXB1CON.rxful=0; 
0504:  MOVLB  F
0506:  BCF    x50.7
....................     } 
....................     else { 
0508:  BRA    0510
050A:  MOVLB  0
....................       RXB0CON.rxful=0; 
050C:  BCF    F60.7
050E:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
0510:  MOVLW  01
0512:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "packet.c" 
.................... #include "packet.h" 
.................... /* 
....................  * packet.h 
....................  * 
....................  *  Created on: Oct 6, 2009 
....................  *      Author: steven 
....................  */ 
....................  
.................... #ifndef PACKET_H_ 
.................... #define PACKET_H_ 
.................... //Packet.h 
.................... // this header file contains the subroutines to create and handle packets 
.................... //    that interact with the HIU(Hardware Interface Unit) 
.................... // 
.................... // Author: Jonathan Holden 
.................... // Date: 10/16/2008 
.................... // Compliant with Developer Code Version 0.3 
.................... //    do not use older developer code as some functionality has changed 
.................... // 
.................... // 
.................... // 
.................... // Incoming_Packet_Parser(Current_Packet[8]) 
.................... // 
.................... // This subroutine will take an incoming packet from the global array (Current_Packet[8]) 
.................... // and break it into the correct parts and place it in the global variables. 
.................... // it will then perform a checksum on the data to insure that the data is not corrupted. 
.................... // 
.................... // 
.................... // PACKET_BUILDER(int TeamID, int16 PlayerID, int SubID, int16 ProcessID, int ReturnID) 
.................... // 
.................... // This routine takes the values in the global variables and forms them into a packet that is ready for communication 
.................... // The packet is stored in Packet_Buffer[8] 
.................... // 
.................... // Packet_Input() 
.................... // 
.................... // This routine will query the user for information and place it in the global variables 
.................... // The IO stream that you are printing to must be named USB 
.................... // 
.................... // 
.................... // Print_Packet() 
.................... // 
.................... // This routine will print the current packet that is in Packet_Buffer[8] 
.................... // The IO stream that you are printing to must be named USB 
....................  
.................... #ifdef __GNUC__ 
....................  
.................... typedef int int16; 
.................... typedef unsigned char int8; 
....................  
.................... #endif 
....................  
....................  
.................... #define IRCOMMID        1 
.................... #define RFCOMMID        2 
.................... #define RFIDCOMMID      3 
.................... #define CANCOMMID       4 
....................  
.................... typedef struct 
.................... { 
....................    int8 COM; 
....................    int8 Team; 
....................    int16 Player; 
....................    int8 Subroutine; 
....................    int16 Process; 
....................    int16 ReturnValue; 
....................    int8 Checksum; 
.................... }Packet; 
....................  
....................  
....................  
....................  
.................... //subroutines 
....................  
.................... //Parses and Incoming Packet and returns the result in a Packet structure 
.................... Packet Incoming_Packet_Parser(int8 Current_Packet[], int size); 
....................  
.................... //Input a Packet and an array of data is returned ready to be transmitted. 
.................... void PacketBuilder(Packet CurrentPacket, int8 PacketBuffer[]); 
....................  
.................... int8 fletcher16( int8 * data, size_t len ); 
....................  
.................... //Packet Packet_Input(); 
....................  
....................  
.................... //void Print_Packet(int * buffer); // modify for 8 & 9 byte packets use size of array 
....................  
.................... //Verifies the checksum of the packet 
.................... int Integrity_Check(int8 * data); 
....................  
.................... #endif /* PACKET_H_ */ 
....................  
....................  
....................  
....................  
.................... Packet Incoming_Packet_Parser(int8 Current_Packet[], int size) 
.................... { 
....................    Packet packetinput; 
....................  
....................    packetinput.COM = 0; 
*
09AE:  CLRF   x95
....................    packetinput.Team = 0; 
09B0:  CLRF   x96
....................    packetinput.Player = 0; 
09B2:  CLRF   x98
09B4:  CLRF   x97
....................    packetinput.Subroutine = 0; 
09B6:  CLRF   x99
....................    packetinput.Process = 0; 
09B8:  CLRF   x9B
09BA:  CLRF   x9A
....................    packetinput.ReturnValue = 0; 
09BC:  CLRF   x9D
09BE:  CLRF   x9C
....................    packetinput.Checksum = 0; 
09C0:  CLRF   x9E
....................  
....................  
....................    if (size==8) 
09C2:  MOVF   x94,W
09C4:  SUBLW  08
09C6:  BNZ   0AA8
....................    { 
....................       packetinput.COM = NULL; 
09C8:  CLRF   x95
....................       packetinput.Team = (Current_Packet[0]); 
09CA:  MOVFF  92,FE9
09CE:  MOVFF  93,FEA
09D2:  MOVFF  FEF,96
....................       packetinput.Player = Current_Packet[1]; 
09D6:  MOVLW  01
09D8:  ADDWF  x92,W
09DA:  MOVWF  FE9
09DC:  MOVLW  00
09DE:  ADDWFC x93,W
09E0:  MOVWF  FEA
09E2:  MOVF   FEF,W
09E4:  CLRF   03
09E6:  MOVWF  x97
09E8:  MOVFF  03,98
....................       packetinput.Player = packetinput.Player*16; 
09EC:  RLCF   x97,F
09EE:  RLCF   x98,F
09F0:  RLCF   x97,F
09F2:  RLCF   x98,F
09F4:  RLCF   x97,F
09F6:  RLCF   x98,F
09F8:  RLCF   x97,F
09FA:  RLCF   x98,F
09FC:  MOVLW  F0
09FE:  ANDWF  x97,F
....................       packetinput.Player = packetinput.Player + ((Current_Packet[2]&0b11110000)/16); 
0A00:  MOVLW  02
0A02:  ADDWF  x92,W
0A04:  MOVWF  FE9
0A06:  MOVLW  00
0A08:  ADDWFC x93,W
0A0A:  MOVWF  FEA
0A0C:  MOVF   FEF,W
0A0E:  ANDLW  F0
0A10:  MOVWF  00
0A12:  SWAPF  00,F
0A14:  MOVLW  0F
0A16:  ANDWF  00,F
0A18:  MOVF   00,W
0A1A:  ADDWF  x97,F
0A1C:  MOVLW  00
0A1E:  ADDWFC x98,F
....................       packetinput.Subroutine = (Current_Packet[2]&0b00001111); 
0A20:  MOVLW  02
0A22:  ADDWF  x92,W
0A24:  MOVWF  FE9
0A26:  MOVLW  00
0A28:  ADDWFC x93,W
0A2A:  MOVWF  FEA
0A2C:  MOVF   FEF,W
0A2E:  ANDLW  0F
0A30:  MOVWF  x99
....................       packetinput.Process = (Current_Packet[3]); 
0A32:  MOVLW  03
0A34:  ADDWF  x92,W
0A36:  MOVWF  FE9
0A38:  MOVLW  00
0A3A:  ADDWFC x93,W
0A3C:  MOVWF  FEA
0A3E:  MOVF   FEF,W
0A40:  CLRF   03
0A42:  MOVWF  x9A
0A44:  MOVFF  03,9B
....................       packetinput.Process = packetinput.Process*256 + Current_Packet[4]; 
0A48:  MOVFF  9A,A0
0A4C:  CLRF   x9F
0A4E:  MOVLW  04
0A50:  ADDWF  x92,W
0A52:  MOVWF  FE9
0A54:  MOVLW  00
0A56:  ADDWFC x93,W
0A58:  MOVWF  FEA
0A5A:  MOVF   FEF,W
0A5C:  ADDWF  x9F,W
0A5E:  MOVWF  x9A
0A60:  MOVLW  00
0A62:  ADDWFC xA0,W
0A64:  MOVWF  x9B
....................       packetinput.ReturnValue = (Current_Packet[5]*256) + (Current_Packet[6]); 
0A66:  MOVLW  05
0A68:  ADDWF  x92,W
0A6A:  MOVWF  FE9
0A6C:  MOVLW  00
0A6E:  ADDWFC x93,W
0A70:  MOVWF  FEA
0A72:  CLRF   xA1
0A74:  MOVFF  FEF,A0
0A78:  MOVLW  01
0A7A:  MOVWF  xA3
0A7C:  CLRF   xA2
0A7E:  RCALL  0990
0A80:  MOVLW  06
0A82:  ADDWF  x92,W
0A84:  MOVWF  FE9
0A86:  MOVLW  00
0A88:  ADDWFC x93,W
0A8A:  MOVWF  FEA
0A8C:  MOVF   FEF,W
0A8E:  ADDWF  01,W
0A90:  MOVWF  x9C
0A92:  MOVLW  00
0A94:  ADDWFC 02,W
0A96:  MOVWF  x9D
....................       packetinput.Checksum = Current_Packet[7]; 
0A98:  MOVLW  07
0A9A:  ADDWF  x92,W
0A9C:  MOVWF  FE9
0A9E:  MOVLW  00
0AA0:  ADDWFC x93,W
0AA2:  MOVWF  FEA
0AA4:  MOVFF  FEF,9E
....................    } 
....................  
....................    if (size==9) 
0AA8:  MOVF   x94,W
0AAA:  SUBLW  09
0AAC:  BNZ   0B9C
....................    { 
....................       packetinput.COM = (Current_Packet[0]); 
0AAE:  MOVFF  92,FE9
0AB2:  MOVFF  93,FEA
0AB6:  MOVFF  FEF,95
....................       packetinput.Team = (Current_Packet[1]); 
0ABA:  MOVLW  01
0ABC:  ADDWF  x92,W
0ABE:  MOVWF  FE9
0AC0:  MOVLW  00
0AC2:  ADDWFC x93,W
0AC4:  MOVWF  FEA
0AC6:  MOVFF  FEF,96
....................       packetinput.Player = Current_Packet[2]; 
0ACA:  MOVLW  02
0ACC:  ADDWF  x92,W
0ACE:  MOVWF  FE9
0AD0:  MOVLW  00
0AD2:  ADDWFC x93,W
0AD4:  MOVWF  FEA
0AD6:  MOVF   FEF,W
0AD8:  CLRF   03
0ADA:  MOVWF  x97
0ADC:  MOVFF  03,98
....................       packetinput.Player = packetinput.Player*16; 
0AE0:  RLCF   x97,F
0AE2:  RLCF   x98,F
0AE4:  RLCF   x97,F
0AE6:  RLCF   x98,F
0AE8:  RLCF   x97,F
0AEA:  RLCF   x98,F
0AEC:  RLCF   x97,F
0AEE:  RLCF   x98,F
0AF0:  MOVLW  F0
0AF2:  ANDWF  x97,F
....................       packetinput.Player = packetinput.Player + ((Current_Packet[3]&0b11110000)/16); 
0AF4:  MOVLW  03
0AF6:  ADDWF  x92,W
0AF8:  MOVWF  FE9
0AFA:  MOVLW  00
0AFC:  ADDWFC x93,W
0AFE:  MOVWF  FEA
0B00:  MOVF   FEF,W
0B02:  ANDLW  F0
0B04:  MOVWF  00
0B06:  SWAPF  00,F
0B08:  MOVLW  0F
0B0A:  ANDWF  00,F
0B0C:  MOVF   00,W
0B0E:  ADDWF  x97,F
0B10:  MOVLW  00
0B12:  ADDWFC x98,F
....................       packetinput.Subroutine = (Current_Packet[3]&0b00001111); 
0B14:  MOVLW  03
0B16:  ADDWF  x92,W
0B18:  MOVWF  FE9
0B1A:  MOVLW  00
0B1C:  ADDWFC x93,W
0B1E:  MOVWF  FEA
0B20:  MOVF   FEF,W
0B22:  ANDLW  0F
0B24:  MOVWF  x99
....................       packetinput.Process = (Current_Packet[4]); 
0B26:  MOVLW  04
0B28:  ADDWF  x92,W
0B2A:  MOVWF  FE9
0B2C:  MOVLW  00
0B2E:  ADDWFC x93,W
0B30:  MOVWF  FEA
0B32:  MOVF   FEF,W
0B34:  CLRF   03
0B36:  MOVWF  x9A
0B38:  MOVFF  03,9B
....................       packetinput.Process = packetinput.Process*256 + Current_Packet[5]; 
0B3C:  MOVFF  9A,A0
0B40:  CLRF   x9F
0B42:  MOVLW  05
0B44:  ADDWF  x92,W
0B46:  MOVWF  FE9
0B48:  MOVLW  00
0B4A:  ADDWFC x93,W
0B4C:  MOVWF  FEA
0B4E:  MOVF   FEF,W
0B50:  ADDWF  x9F,W
0B52:  MOVWF  x9A
0B54:  MOVLW  00
0B56:  ADDWFC xA0,W
0B58:  MOVWF  x9B
....................       packetinput.ReturnValue = (Current_Packet[6]*256) + (Current_Packet[7]); 
0B5A:  MOVLW  06
0B5C:  ADDWF  x92,W
0B5E:  MOVWF  FE9
0B60:  MOVLW  00
0B62:  ADDWFC x93,W
0B64:  MOVWF  FEA
0B66:  CLRF   xA1
0B68:  MOVFF  FEF,A0
0B6C:  MOVLW  01
0B6E:  MOVWF  xA3
0B70:  CLRF   xA2
0B72:  RCALL  0990
0B74:  MOVLW  07
0B76:  ADDWF  x92,W
0B78:  MOVWF  FE9
0B7A:  MOVLW  00
0B7C:  ADDWFC x93,W
0B7E:  MOVWF  FEA
0B80:  MOVF   FEF,W
0B82:  ADDWF  01,W
0B84:  MOVWF  x9C
0B86:  MOVLW  00
0B88:  ADDWFC 02,W
0B8A:  MOVWF  x9D
....................       packetinput.Checksum = Current_Packet[8]; 
0B8C:  MOVLW  08
0B8E:  ADDWF  x92,W
0B90:  MOVWF  FE9
0B92:  MOVLW  00
0B94:  ADDWFC x93,W
0B96:  MOVWF  FEA
0B98:  MOVFF  FEF,9E
....................        
....................    } 
....................    return packetinput; 
0B9C:  MOVLW  95
0B9E:  MOVWF  01
0BA0:  CLRF   02
.................... } 
0BA2:  GOTO   145C (RETURN)
....................  
....................  
.................... int Integrity_Check(int8 * data) 
.................... { 
....................    int checka = 0,checkb = 0; 
*
0C48:  CLRF   x8E
0C4A:  CLRF   x8F
....................    int8 IntegrityCHK = 0; 
0C4C:  CLRF   x90
....................     
....................    checka = fletcher16(&data[0], 7); 
0C4E:  MOVFF  8C,91
0C52:  MOVFF  8D,92
0C56:  MOVFF  8D,94
0C5A:  MOVFF  8C,93
0C5E:  MOVLW  07
0C60:  MOVWF  x95
0C62:  BRA    0BA6
0C64:  MOVFF  01,8E
....................    if((data[7]!=checka)) 
0C68:  MOVLW  07
0C6A:  ADDWF  x8C,W
0C6C:  MOVWF  FE9
0C6E:  MOVLW  00
0C70:  ADDWFC x8D,W
0C72:  MOVWF  FEA
0C74:  MOVF   x8E,W
0C76:  SUBWF  FEF,W
0C78:  BZ    0C82
....................       return 0; 
0C7A:  MOVLW  00
0C7C:  MOVWF  01
0C7E:  BRA    0C88
....................        
....................    else 
0C80:  BRA    0C88
....................       return 1; 
0C82:  MOVLW  01
0C84:  MOVWF  01
0C86:  BRA    0C88
....................     
.................... } 
0C88:  GOTO   148E (RETURN)
....................  
....................  
.................... void PacketBuilder(Packet CurrentPacket, int8 * PacketBuffer) 
.................... { 
....................    int chka,chkb; 
....................     
....................    if (CurrentPacket.COM != 0) 
....................    { 
....................        
....................       PacketBuffer[0]=CurrentPacket.COM; 
....................       PacketBuffer[1]=CurrentPacket.Team; 
....................       PacketBuffer[2]=((CurrentPacket.Player&0b0000111111110000)/16); 
....................       PacketBuffer[3]=((CurrentPacket.Player&0b0000000000001111)*16); 
....................       PacketBuffer[3]=PacketBuffer[3] + (CurrentPacket.Subroutine&0b00001111); 
....................       PacketBuffer[4]=((CurrentPacket.Process&0b1111111100000000)/256); 
....................       PacketBuffer[5]=((CurrentPacket.Process&0b0000000011111111)); 
....................       PacketBuffer[6]=((CurrentPacket.ReturnValue&0b1111111100000000)/256); 
....................       PacketBuffer[7]=((CurrentPacket.ReturnValue&0b0000000011111111));    
....................        
....................       PacketBuffer[8]=fletcher16(&PacketBuffer[1], 7); 
....................    } 
....................    else if (CurrentPacket.COM == 0) 
....................    { 
....................        
....................       PacketBuffer[0]=CurrentPacket.Team; 
....................       PacketBuffer[1]=((CurrentPacket.Player&0b0000111111110000)/16); 
....................       PacketBuffer[2]=((CurrentPacket.Player&0b0000000000001111)*16); 
....................       PacketBuffer[2]=PacketBuffer[2] + (CurrentPacket.Subroutine&0b00001111); 
....................       PacketBuffer[3]=((CurrentPacket.Process&0b1111111100000000)/256); 
....................       PacketBuffer[4]=((CurrentPacket.Process&0b0000000011111111)); 
....................       PacketBuffer[5]=((CurrentPacket.ReturnValue&0b1111111100000000)/256); 
....................       PacketBuffer[6]=((CurrentPacket.ReturnValue&0b0000000011111111)); 
....................        
....................       PacketBuffer[7]=fletcher16(&PacketBuffer[0], 7); 
....................    } 
....................  
.................... } 
....................  
.................... int8 fletcher16( int8 * data, size_t len ) 
.................... { 
....................    size_t tlen; 
....................         int16 sum1 = 0xff, sum2 = 0xff; 
*
0BA6:  MOVLW  FF
0BA8:  MOVWF  x97
0BAA:  CLRF   x98
0BAC:  MOVWF  x99
0BAE:  CLRF   x9A
....................         while (len) { 
0BB0:  MOVF   x95,F
0BB2:  BZ    0C18
....................                 if(len > 21) 
0BB4:  MOVF   x95,W
0BB6:  SUBLW  15
0BB8:  BC    0BC0
....................                   tlen = 21; 
0BBA:  MOVLW  15
0BBC:  MOVWF  x96
....................                 else 
0BBE:  BRA    0BC4
....................                   tlen = len; 
0BC0:  MOVFF  95,96
....................                 len -= tlen; 
0BC4:  MOVF   x96,W
0BC6:  SUBWF  x95,F
....................                 do { 
....................                         sum1 += *data++; 
0BC8:  MOVFF  94,03
0BCC:  MOVF   x93,W
0BCE:  INCF   x93,F
0BD0:  BTFSC  FD8.2
0BD2:  INCF   x94,F
0BD4:  MOVWF  FE9
0BD6:  MOVFF  03,FEA
0BDA:  MOVF   FEF,W
0BDC:  ADDWF  x97,F
0BDE:  MOVLW  00
0BE0:  ADDWFC x98,F
....................                         sum2 += sum1; 
0BE2:  MOVF   x97,W
0BE4:  ADDWF  x99,F
0BE6:  MOVF   x98,W
0BE8:  ADDWFC x9A,F
....................                 } while (--tlen); 
0BEA:  DECFSZ x96,F
0BEC:  BRA    0BC8
....................                 sum1 = (sum1 & 0xff) + (sum1 >> 8); 
0BEE:  MOVFF  97,9B
0BF2:  CLRF   x9C
0BF4:  MOVF   x98,W
0BF6:  CLRF   03
0BF8:  ADDWF  x97,W
0BFA:  MOVWF  x97
0BFC:  MOVF   03,W
0BFE:  ADDWFC x9C,W
0C00:  MOVWF  x98
....................                 sum2 = (sum2 & 0xff) + (sum2 >> 8); 
0C02:  MOVFF  99,9B
0C06:  CLRF   x9C
0C08:  MOVF   x9A,W
0C0A:  CLRF   03
0C0C:  ADDWF  x99,W
0C0E:  MOVWF  x99
0C10:  MOVF   03,W
0C12:  ADDWFC x9C,W
0C14:  MOVWF  x9A
....................         } 
0C16:  BRA    0BB0
....................         /* Second reduction step to reduce sums to 8 bits */ 
....................         sum1 = (sum1 & 0xff) + (sum1 >> 8); 
0C18:  MOVFF  97,9B
0C1C:  CLRF   x9C
0C1E:  MOVF   x98,W
0C20:  CLRF   03
0C22:  ADDWF  x97,W
0C24:  MOVWF  x97
0C26:  MOVF   03,W
0C28:  ADDWFC x9C,W
0C2A:  MOVWF  x98
....................         sum2 = (sum2 & 0xff) + (sum2 >> 8); 
0C2C:  MOVFF  99,9B
0C30:  CLRF   x9C
0C32:  MOVF   x9A,W
0C34:  CLRF   03
0C36:  ADDWF  x99,W
0C38:  MOVWF  x99
0C3A:  MOVF   03,W
0C3C:  ADDWFC x9C,W
0C3E:  MOVWF  x9A
....................        // *checkA = (int8)sum1; 
....................        // *checkB = (int8)sum2; 
....................         return (int8)sum2; 
0C40:  MOVFF  99,01
.................... } 
0C44:  GOTO   0C64 (RETURN)
.................... //Packet Packet_Input() 
.................... //{ 
.................... //   Packet packetinput; 
.................... //   char* temp[6]; 
.................... // 
.................... //   fprintf(USB,"\n\r Please enter Team ID\n\r"); 
.................... //   fgets(temp, USB); 
.................... //   if (temp[strlen(temp)-1] == '\n') 
.................... //      temp[strlen(temp)-1] = '\0'; 
.................... //   packetinput.Team = (int8)strtoul(temp,null,0); 
.................... //   fprintf(USB,"  %u  ",packetinput.Team); 
.................... // 
.................... //   fprintf(USB,"\n\r Please enter Player ID\n\r"); 
.................... //   fgets(temp, USB); 
.................... //   if (temp[strlen(temp)-1] == '\n') 
.................... //      temp[strlen(temp)-1] = '\0'; 
.................... //   packetinput.Player = strtoul(temp,null,0); 
.................... //   fprintf(USB,"  %lu  ",packetinput.Player); 
.................... // 
.................... //   fprintf(USB,"\n\r Please enter Subroutine ID\n\r"); 
.................... //   fgets(temp, USB); 
.................... //   if (temp[strlen(temp)-1] == '\n') 
.................... //      temp[strlen(temp)-1] = '\0'; 
.................... //   packetinput.Subroutine = (int8)strtoul(temp,null,0); 
.................... //   fprintf(USB,"  %u  ",packetinput.Subroutine); 
.................... // 
.................... //   fprintf(USB,"\n\r Please enter Process ID\n\r"); 
.................... //   fgets(temp, USB); 
.................... //   if (temp[strlen(temp)-1] == '\n') 
.................... //      temp[strlen(temp)-1] = '\0'; 
.................... //   packetinput.Process = strtoul(temp,null,0); 
.................... //   fprintf(USB,"  %lu  ",packetinput.Process); 
.................... // 
.................... //   fprintf(USB,"\n\r Please enter Return Value\n\r"); 
.................... //   fgets(temp, USB); 
.................... //   if (temp[strlen(temp)-1] == '\n') 
.................... //      temp[strlen(temp)-1] = '\0'; 
.................... //   packetinput.ReturnValue = strtoul(temp,null,0); 
.................... //   fprintf(USB,"  %lu  ",packetinput.ReturnValue); 
.................... // 
.................... //   return packetinput; 
.................... //} 
....................  
.................... //void Print_Packet(int * buffer) 
.................... //{ 
.................... //   fprintf(USB,"\n\r  current packet  \n\r"); 
.................... //   fprintf(USB," %u  %u  %u  %u  %u  %u  %u  %u \n\r",buffer[0],buffer[1],buffer[2],buffer[3],buffer[4],buffer[5],buffer[6],buffer[7]); 
.................... // 
.................... //} 
....................  
....................  
....................  
....................  
....................  
.................... #include "IR_rx.h" 
.................... /* 
.................... This header enables support for the MAGE IR protocol. This code assumes a PIC18F2480 or 2580 
.................... is being used with a 20MHz clock for receiving and a PIC16F688 is being used for transmitting. 
.................... Also the IR receiver should be a TSOP36256. Some other receivers 
.................... may work, but this one has been found to have good range and do a very good job of blocking 
.................... noise. 
....................  
.................... Author: Bruce Lebold 
.................... Date: 07/18/2010 
....................  
.................... !!! Any hardware changes may affect the performance of the IR protocol.!!! 
....................  
.................... If IR data becomes inaccurate due to hardware changes, you will most likely need 
.................... to adjust timer2. This will affect the timing of the period which is sampled for each bit. 
....................  
.................... setup_timer_2(T2_DIV_BY_16,141,4); is the original setting using the assumed hardware. 
....................  
.................... */ 
....................  
....................  
....................  
.................... // IR global vars 
.................... int1 ir_start = 0; 
.................... int8 ir_bit[64]; 
.................... int8 IR_buffer[8]; 
.................... int8 ir_bit_count = 0; 
.................... int1 IR_data_ready = 0; 
....................  
.................... void decode_IR() 
.................... { 
....................    //decode the 64 values stored into an 8 byte packet 
....................    int8 i = 0; 
*
0144:  CLRF   xAB
....................    int8 h = 0; 
0146:  CLRF   xAC
....................    int8 index = 0; 
0148:  CLRF   xAD
....................     
....................    for(i=0;i<64;i++) //for all 64 elements in the IR_bit array 
014A:  CLRF   xAB
014C:  MOVF   xAB,W
014E:  SUBLW  3F
0150:  BNC   018E
....................    { 
....................       if(IR_bit[i] > 2) // if that element is > 2, the bit is 0 
0152:  CLRF   03
0154:  MOVF   xAB,W
0156:  ADDLW  1F
0158:  MOVWF  FE9
015A:  MOVLW  00
015C:  ADDWFC 03,W
015E:  MOVWF  FEA
0160:  MOVF   FEF,W
0162:  SUBLW  02
0164:  BC    0178
....................       { 
....................          IR_bit[i] = 0; 
0166:  CLRF   03
0168:  MOVF   xAB,W
016A:  ADDLW  1F
016C:  MOVWF  FE9
016E:  MOVLW  00
0170:  ADDWFC 03,W
0172:  MOVWF  FEA
0174:  CLRF   FEF
....................       } 
....................       else //if that element is 2 or less, the bit is a 1 
0176:  BRA    018A
....................       {   
....................          IR_bit[i] = 1; 
0178:  CLRF   03
017A:  MOVF   xAB,W
017C:  ADDLW  1F
017E:  MOVWF  FE9
0180:  MOVLW  00
0182:  ADDWFC 03,W
0184:  MOVWF  FEA
0186:  MOVLW  01
0188:  MOVWF  FEF
....................       }   
....................    } 
018A:  INCF   xAB,F
018C:  BRA    014C
....................     
....................    for(h = 0; h<8; h++) // convert the 64 bits into 8 bytes 
018E:  CLRF   xAC
0190:  MOVF   xAC,W
0192:  SUBLW  07
0194:  BNC   01EC
....................    { 
....................        for (i = 0; i < 8; i++) 
0196:  CLRF   xAB
0198:  MOVF   xAB,W
019A:  SUBLW  07
019C:  BNC   01E4
....................        { 
....................           IR_buffer[h] = IR_buffer[h]*2 + IR_bit[index+i]; 
019E:  CLRF   03
01A0:  MOVF   xAC,W
01A2:  ADDLW  5F
01A4:  MOVWF  01
01A6:  MOVLW  00
01A8:  ADDWFC 03,F
01AA:  MOVFF  03,AF
01AE:  CLRF   03
01B0:  MOVF   xAC,W
01B2:  ADDLW  5F
01B4:  MOVWF  FE9
01B6:  MOVLW  00
01B8:  ADDWFC 03,W
01BA:  MOVWF  FEA
01BC:  BCF    FD8.0
01BE:  RLCF   FEF,W
01C0:  MOVWF  xB1
01C2:  MOVF   xAB,W
01C4:  ADDWF  xAD,W
01C6:  CLRF   03
01C8:  ADDLW  1F
01CA:  MOVWF  FE9
01CC:  MOVLW  00
01CE:  ADDWFC 03,W
01D0:  MOVWF  FEA
01D2:  MOVF   FEF,W
01D4:  ADDWF  xB1,W
01D6:  MOVFF  AF,FEA
01DA:  MOVFF  01,FE9
01DE:  MOVWF  FEF
....................        } 
01E0:  INCF   xAB,F
01E2:  BRA    0198
....................         
....................        index+=8; 
01E4:  MOVLW  08
01E6:  ADDWF  xAD,F
....................    } 
01E8:  INCF   xAC,F
01EA:  BRA    0190
....................     
....................    for(i=0;i<64;i++) //clear the bit values 
01EC:  CLRF   xAB
01EE:  MOVF   xAB,W
01F0:  SUBLW  3F
01F2:  BNC   0208
....................    { 
....................       IR_bit[i] = 0;     
01F4:  CLRF   03
01F6:  MOVF   xAB,W
01F8:  ADDLW  1F
01FA:  MOVWF  FE9
01FC:  MOVLW  00
01FE:  ADDWFC 03,W
0200:  MOVWF  FEA
0202:  CLRF   FEF
....................    } 
0204:  INCF   xAB,F
0206:  BRA    01EE
.................... } 
0208:  GOTO   021E (RETURN)
....................  
.................... #int_EXT 
.................... void  EXT_isr(void)  
.................... { 
....................    //IR_data_ready = 1; 
....................    //output_toggle(RED); 
....................  
....................    if(ir_start == 0) //if a start bit has not yet been received 
*
011A:  BTFSC  1E.0
011C:  BRA    012E
....................    { 
....................       ir_start = 1; //set flag 
011E:  BSF    1E.0
....................       delay_us(10); //delay 
0120:  MOVLW  10
0122:  MOVWF  00
0124:  DECFSZ 00,F
0126:  BRA    0124
0128:  NOP   
....................       set_timer2(0); //get ready to store data using timer2 to time bits 
012A:  CLRF   FCC
....................    } 
....................     
....................    else //if the start bit has already been received 
012C:  BRA    013E
....................    { 
....................       ir_bit[ir_bit_count]++; //increase the counter for # of interrupts caused by IR during this bit's time period 
012E:  CLRF   03
0130:  MOVF   x67,W
0132:  ADDLW  1F
0134:  MOVWF  FE9
0136:  MOVLW  00
0138:  ADDWFC 03,W
013A:  MOVWF  FEA
013C:  INCF   FEF,F
....................    } 
....................  
.................... } 
....................  
013E:  BCF    FF2.1
0140:  GOTO   007C
.................... #int_TIMER2 
.................... void  TIMER2_isr(void)  
.................... { 
....................     
....................    if(ir_start == 1) //change ir_bit_count every ? us so ext_isr can know what bit to tally interrupts for 
*
020C:  BTFSS  1E.0
020E:  BRA    0226
....................    { 
....................       if(ir_bit_count < 64) 
0210:  MOVF   x67,W
0212:  SUBLW  3F
0214:  BNC   021A
....................       { 
....................         ir_bit_count++; 
0216:  INCF   x67,F
....................       } 
....................       else // if all 64 bits have been tallied, decode the IR packet 
0218:  BRA    0226
....................       { 
....................          disable_interrupts(INT_TIMER2); 
021A:  BCF    F9D.1
....................          decode_IR(); 
021C:  BRA    0144
....................          IR_data_ready = 1; 
021E:  BSF    1E.1
....................          ir_start = 0; 
0220:  BCF    1E.0
....................          ir_bit_count = 0; 
0222:  CLRF   x67
....................          enable_interrupts(INT_TIMER2); 
0224:  BSF    F9D.1
....................       } 
....................    } 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... // CAN global vars 
0226:  BCF    F9E.1
0228:  GOTO   007C
.................... int rx_len; 
.................... int32 rx_id; 
.................... int1 can_waiting; 
.................... struct rx_stat rxstat; 
.................... int1 CAN_data_ready; 
.................... int8 CAN_buffer[9]; 
....................  
.................... // light flashing enable vars 
.................... int8 green_countdown; 
.................... int8 yellow_countdown; 
.................... int8 red_countdown; 
....................     
.................... // prototypes 
.................... void initialize(); 
.................... void update_lights(float rat); 
.................... void change_lights(int16 process); 
....................  
.................... void initialize() 
.................... { 
....................    can_waiting = 0; 
*
07DA:  BCF    1E.2
....................    green_countdown = 0; 
07DC:  CLRF   x77
....................    yellow_countdown = 0; 
07DE:  CLRF   x78
....................    red_countdown = 0; 
07E0:  CLRF   x79
....................     
....................    can_init(); 
07E2:  BRA    06EC
....................     
....................    output_low(CAN_RS); 
07E4:  BCF    F94.5
07E6:  BCF    F8B.5
....................    enable_interrupts(int_canrx0);  
07E8:  BSF    FA3.0
....................    enable_interrupts(int_rda); 
07EA:  BSF    F9D.5
....................    enable_interrupts(int_TIMER0);  
07EC:  BSF    FF2.5
....................    enable_interrupts(int_TIMER2); 
07EE:  BSF    F9D.1
....................    enable_interrupts(int_EXT); 
07F0:  BSF    FF2.4
....................     
....................    setup_adc_ports(NO_ANALOGS|VSS_VDD); 
07F2:  MOVF   FC1,W
07F4:  ANDLW  C0
07F6:  IORLW  0F
07F8:  MOVWF  FC1
....................    setup_adc(ADC_OFF|ADC_TAD_MUL_0); 
07FA:  BCF    FC2.0
....................    setup_spi(SPI_SS_DISABLED); 
07FC:  BCF    FC6.5
07FE:  BCF    F94.5
0800:  BSF    F94.4
0802:  BCF    F94.3
0804:  MOVLW  01
0806:  MOVWF  FC6
0808:  MOVLW  00
080A:  MOVWF  FC7
....................    setup_wdt(WDT_OFF); 
080C:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16 ); 
080E:  MOVLW  83
0810:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
0812:  CLRF   FCD
....................    setup_timer_2(T2_DIV_BY_16,141,4); 
0814:  MOVLW  18
0816:  IORLW  06
0818:  MOVWF  FCA
081A:  MOVLW  8D
081C:  MOVWF  FCB
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
081E:  CLRF   FB1
....................    setup_vref(FALSE); 
0820:  CLRF   FB5
....................     
....................    enable_interrupts(GLOBAL); 
0822:  MOVLW  C0
0824:  IORWF  FF2,F
....................  
....................    // Set low all unused pins 
....................    output_low(pin_b4); 
0826:  BCF    F93.4
0828:  BCF    F8A.4
....................    output_low(pin_b5); 
082A:  BCF    F93.5
082C:  BCF    F8A.5
....................    output_low(pin_b1); 
082E:  BCF    F93.1
0830:  BCF    F8A.1
....................    output_low(pin_c3); 
0832:  BCF    F94.3
0834:  BCF    F8B.3
....................    output_low(pin_c4); 
0836:  BCF    F94.4
0838:  BCF    F8B.4
....................    output_low(pin_c0); 
083A:  BCF    F94.0
083C:  BCF    F8B.0
....................    output_low(pin_c1); 
083E:  BCF    F94.1
0840:  BCF    F8B.1
....................    output_low(pin_a2); 
0842:  BCF    F92.2
0844:  BCF    F89.2
....................    output_low(pin_a3); 
0846:  BCF    F92.3
0848:  BCF    F89.3
....................    output_low(pin_a4); 
084A:  BCF    F92.4
084C:  BCF    F89.4
....................    output_low(pin_a5); 
084E:  BCF    F92.5
0850:  BCF    F89.5
....................     
....................    //LED power on test sequence 
....................    output_low(GREEN); 
0852:  BCF    F92.0
0854:  BCF    F89.0
....................    output_low(YELLOW); 
0856:  BCF    F94.2
0858:  BCF    F8B.2
....................    output_low(RED); 
085A:  BCF    F92.1
085C:  BCF    F89.1
....................    delay_ms(500); 
085E:  MOVLW  02
0860:  MOVWF  x8C
0862:  MOVLW  FA
0864:  MOVWF  x8D
0866:  RCALL  07B4
0868:  DECFSZ x8C,F
086A:  BRA    0862
....................    output_high(GREEN); 
086C:  BCF    F92.0
086E:  BSF    F89.0
....................    delay_ms(100); 
0870:  MOVLW  64
0872:  MOVWF  x8D
0874:  RCALL  07B4
....................    output_high(YELLOW); 
0876:  BCF    F94.2
0878:  BSF    F8B.2
....................    delay_ms(100); 
087A:  MOVLW  64
087C:  MOVWF  x8D
087E:  RCALL  07B4
....................    output_high(RED); 
0880:  BCF    F92.1
0882:  BSF    F89.1
....................    delay_ms(100); 
0884:  MOVLW  64
0886:  MOVWF  x8D
0888:  RCALL  07B4
....................    output_low(GREEN); 
088A:  BCF    F92.0
088C:  BCF    F89.0
....................    delay_ms(100); 
088E:  MOVLW  64
0890:  MOVWF  x8D
0892:  RCALL  07B4
....................    output_low(YELLOW); 
0894:  BCF    F94.2
0896:  BCF    F8B.2
....................    delay_ms(100); 
0898:  MOVLW  64
089A:  MOVWF  x8D
089C:  RCALL  07B4
....................    output_low(RED); 
089E:  BCF    F92.1
08A0:  BCF    F89.1
....................    delay_ms(100); 
08A2:  MOVLW  64
08A4:  MOVWF  x8D
08A6:  RCALL  07B4
....................     
....................    fprintf(USB,"Headband Initialized!@#"); 
08A8:  CLRF   x8C
08AA:  MOVF   x8C,W
08AC:  RCALL  00C2
08AE:  INCF   x8C,F
08B0:  MOVWF  00
08B2:  MOVF   00,W
08B4:  BTFSS  F9E.4
08B6:  BRA    08B4
08B8:  MOVWF  FAD
08BA:  MOVLW  17
08BC:  SUBWF  x8C,W
08BE:  BNZ   08AA
.................... } 
08C0:  GOTO   1424 (RETURN)
....................  
....................  
.................... void main() 
.................... { 
*
13E0:  CLRF   FF8
13E2:  BCF    FD0.7
13E4:  BSF    0D.7
13E6:  CLRF   FEA
13E8:  CLRF   FE9
13EA:  BSF    FB8.3
13EC:  MOVLW  56
13EE:  MOVWF  FAF
13F0:  MOVLW  00
13F2:  MOVWF  FB0
13F4:  MOVLW  A6
13F6:  MOVWF  FAC
13F8:  MOVLW  90
13FA:  MOVWF  FAB
13FC:  MOVF   FC1,W
13FE:  ANDLW  C0
1400:  IORLW  0F
1402:  MOVWF  FC1
1404:  CLRF   18
1406:  CLRF   19
1408:  BCF    1E.0
140A:  CLRF   x67
140C:  BCF    1E.1
....................    Packet CAN_packet; 
....................    float ratio=0; 
140E:  CLRF   x84
1410:  CLRF   x85
1412:  CLRF   x86
1414:  CLRF   x87
....................    int16 current_health = 1, max_health = 1; 
1416:  MOVLW  01
1418:  MOVWF  x88
141A:  CLRF   x89
141C:  MOVWF  x8A
141E:  CLRF   x8B
....................     
....................    initialize(); 
1420:  GOTO   07DA
....................      
....................    while(1) 
....................    {   
....................       if(IR_data_ready) // if an IR packet has been read 
1424:  BTFSS  1E.1
1426:  BRA    144A
....................       {        
....................          //output_toggle(YELLOW); 
....................          //if(Integrity_Check(&IR_buffer[0])&&((IR_buffer[0]&IR_buffer[1]&IR_buffer[2]&IR_buffer[3]&IR_buffer[4]&IR_buffer[5]&IR_buffer[6]&IR_buffer[7])!=0xFF)) // if the IR packet was valid 
....................          //{ 
....................             can_putd(0x08, &IR_buffer[0], 8,1,0,0); // put the packet on CANbus (using id 8 to signify ir packet, though this does not matter) 
1428:  CLRF   x8F
142A:  CLRF   x8E
142C:  CLRF   x8D
142E:  MOVLW  08
1430:  MOVWF  x8C
1432:  CLRF   x91
1434:  MOVLW  5F
1436:  MOVWF  x90
1438:  MOVLW  08
143A:  MOVWF  x92
143C:  MOVLW  01
143E:  MOVWF  x93
1440:  CLRF   x94
1442:  CLRF   x95
1444:  GOTO   08C4
....................          //} 
....................              
....................          IR_data_ready = 0; //clear ir ready flag 
1448:  BCF    1E.1
....................       } 
....................        
....................        
....................       if (can_waiting)   //if a can packet with id 7 (signifying a char status packet) has been received 
144A:  BTFSS  1E.2
144C:  BRA    1596
....................       {          
....................          CAN_packet = Incoming_Packet_Parser(&CAN_buffer[0],8); 
144E:  CLRF   x93
1450:  MOVLW  6E
1452:  MOVWF  x92
1454:  MOVLW  08
1456:  MOVWF  x94
1458:  GOTO   09AE
145C:  MOVFF  02,03
1460:  MOVFF  01,8C
1464:  MOVFF  02,8D
1468:  CLRF   FEA
146A:  MOVLW  7A
146C:  MOVWF  FE9
146E:  MOVFF  02,FE2
1472:  MOVFF  01,FE1
1476:  MOVLW  0A
1478:  MOVWF  01
147A:  MOVFF  FE6,FEE
147E:  DECFSZ 01,F
1480:  BRA    147A
....................          can_waiting = 0; //clear received flag immediately so another packet can be recieved 
1482:  BCF    1E.2
....................           
....................          if(Integrity_Check(&CAN_buffer[0])||1) // if the packet is valid (currently always accepted as invalid can packets are unlikely) 
1484:  CLRF   x8D
1486:  MOVLW  6E
1488:  MOVWF  x8C
148A:  GOTO   0C48
....................          { 
....................             CAN_data_ready = 1; // set flag signifying valid packet 
148E:  BSF    1E.3
....................          }      
....................        
....................          if(CAN_data_ready) //if valid packet received 
1490:  BTFSS  1E.3
1492:  BRA    1596
....................          { 
....................             // if a packet containing current char health or max char health is received, 
....................             // update lights according to the calculated ratio. 
....................              
....................             if(CAN_packet.Process == 5) 
1494:  MOVF   x7F,W
1496:  SUBLW  05
1498:  BNZ   1514
149A:  MOVF   x80,F
149C:  BNZ   1514
....................             { 
....................                current_health = CAN_packet.ReturnValue; 
149E:  MOVFF  82,89
14A2:  MOVFF  81,88
....................                ratio = (float)current_health/(float)max_health; 
14A6:  MOVFF  89,91
14AA:  MOVFF  88,90
14AE:  CALL   0C8C
14B2:  MOVFF  00,8C
14B6:  MOVFF  01,8D
14BA:  MOVFF  02,8E
14BE:  MOVFF  03,8F
14C2:  MOVFF  8B,91
14C6:  MOVFF  8A,90
14CA:  CALL   0C8C
14CE:  MOVFF  8F,93
14D2:  MOVFF  8E,92
14D6:  MOVFF  8D,91
14DA:  MOVFF  8C,90
14DE:  MOVFF  03,97
14E2:  MOVFF  02,96
14E6:  MOVFF  01,95
14EA:  MOVFF  00,94
14EE:  CALL   0CC2
14F2:  MOVFF  03,87
14F6:  MOVFF  02,86
14FA:  MOVFF  01,85
14FE:  MOVFF  00,84
....................                update_lights(ratio); 
1502:  MOVFF  87,8F
1506:  MOVFF  86,8E
150A:  MOVFF  85,8D
150E:  MOVFF  84,8C
1512:  RCALL  1254
....................             } 
....................              
....................             if(CAN_packet.Process == 8) 
1514:  MOVF   x7F,W
1516:  SUBLW  08
1518:  BNZ   1594
151A:  MOVF   x80,F
151C:  BNZ   1594
....................             { 
....................                max_health = CAN_packet.ReturnValue; 
151E:  MOVFF  82,8B
1522:  MOVFF  81,8A
....................                ratio = (float)current_health/(float)max_health; 
1526:  MOVFF  89,91
152A:  MOVFF  88,90
152E:  CALL   0C8C
1532:  MOVFF  00,8C
1536:  MOVFF  01,8D
153A:  MOVFF  02,8E
153E:  MOVFF  03,8F
1542:  MOVFF  8B,91
1546:  MOVFF  8A,90
154A:  CALL   0C8C
154E:  MOVFF  8F,93
1552:  MOVFF  8E,92
1556:  MOVFF  8D,91
155A:  MOVFF  8C,90
155E:  MOVFF  03,97
1562:  MOVFF  02,96
1566:  MOVFF  01,95
156A:  MOVFF  00,94
156E:  CALL   0CC2
1572:  MOVFF  03,87
1576:  MOVFF  02,86
157A:  MOVFF  01,85
157E:  MOVFF  00,84
....................                update_lights(ratio); 
1582:  MOVFF  87,8F
1586:  MOVFF  86,8E
158A:  MOVFF  85,8D
158E:  MOVFF  84,8C
1592:  RCALL  1254
....................             } 
....................                 
....................             CAN_data_ready = 0; //clear packet flag 
1594:  BCF    1E.3
....................          }          
....................       } 
....................            
....................    } // End WHILE loop 
1596:  BRA    1424
....................  } //End main() 
....................  
....................  
....................  
.................... #int_canrx0 
.................... void canrx0_int ( )  
1598:  SLEEP 
.................... { 
....................    can_getd(rx_id, &CAN_buffer[0], rx_len, rxstat); //store any received packet 
*
040A:  CLRF   xAC
040C:  MOVLW  6E
040E:  MOVWF  xAB
....................    //output_toggle(YELLOW); 
....................    if (rx_id == 0x07) // if the packet is id 7 
*
0514:  MOVLB  0
0516:  MOVF   x69,W
0518:  SUBLW  07
051A:  BNZ   052A
051C:  MOVF   x6A,F
051E:  BNZ   052A
0520:  MOVF   x6B,F
0522:  BNZ   052A
0524:  MOVF   x6C,F
0526:  BNZ   052A
....................       can_waiting = 1; // set flag showing a can packet is ready to be processed 
0528:  BSF    1E.2
.................... } 
....................  
052A:  BCF    FA4.0
052C:  GOTO   007C
.................... void update_lights(float rat) 
.................... { 
....................    //update light sequence based on rat argument using change_lights(); 
....................     
....................    fprintf(USB, "\r\nratio: %f", rat); 
*
1254:  CLRF   x90
1256:  MOVF   x90,W
1258:  CALL   00F4
125C:  INCF   x90,F
125E:  MOVWF  00
1260:  MOVF   00,W
1262:  BTFSS  F9E.4
1264:  BRA    1262
1266:  MOVWF  FAD
1268:  MOVLW  09
126A:  SUBWF  x90,W
126C:  BNZ   1256
126E:  MOVLW  89
1270:  MOVWF  FE9
1272:  MOVFF  8F,94
1276:  MOVFF  8E,93
127A:  MOVFF  8D,92
127E:  MOVFF  8C,91
1282:  MOVLW  02
1284:  MOVWF  x95
1286:  BRA    0FCA
....................    if (rat <= -0.1) 
1288:  MOVFF  8F,93
128C:  MOVFF  8E,92
1290:  MOVFF  8D,91
1294:  MOVFF  8C,90
1298:  MOVLW  CD
129A:  MOVWF  x97
129C:  MOVLW  CC
129E:  MOVWF  x96
12A0:  MOVWF  x95
12A2:  MOVLW  7B
12A4:  MOVWF  x94
12A6:  RCALL  1152
12A8:  BC    12AC
12AA:  BNZ   12B6
....................    { 
....................       change_lights(0b00001000); 
12AC:  CLRF   x91
12AE:  MOVLW  08
12B0:  MOVWF  x90
12B2:  RCALL  11C8
....................    } 
....................     
....................    else if (rat <= 0.0) 
12B4:  BRA    13DE
12B6:  MOVFF  8F,93
12BA:  MOVFF  8E,92
12BE:  MOVFF  8D,91
12C2:  MOVFF  8C,90
12C6:  CLRF   x97
12C8:  CLRF   x96
12CA:  CLRF   x95
12CC:  CLRF   x94
12CE:  RCALL  1152
12D0:  BC    12D4
12D2:  BNZ   12DE
....................    { 
....................       change_lights(0b00001001); 
12D4:  CLRF   x91
12D6:  MOVLW  09
12D8:  MOVWF  x90
12DA:  RCALL  11C8
....................    } 
....................     
....................    else if (rat <= 0.1) 
12DC:  BRA    13DE
12DE:  MOVFF  8F,93
12E2:  MOVFF  8E,92
12E6:  MOVFF  8D,91
12EA:  MOVFF  8C,90
12EE:  MOVLW  CD
12F0:  MOVWF  x97
12F2:  MOVLW  CC
12F4:  MOVWF  x96
12F6:  MOVLW  4C
12F8:  MOVWF  x95
12FA:  MOVLW  7B
12FC:  MOVWF  x94
12FE:  RCALL  1152
1300:  BC    1304
1302:  BNZ   130E
....................    { 
....................       change_lights(0b00011000); 
1304:  CLRF   x91
1306:  MOVLW  18
1308:  MOVWF  x90
130A:  RCALL  11C8
....................    }  
....................     
....................    else if (rat <= 0.25) 
130C:  BRA    13DE
130E:  MOVFF  8F,93
1312:  MOVFF  8E,92
1316:  MOVFF  8D,91
131A:  MOVFF  8C,90
131E:  CLRF   x97
1320:  CLRF   x96
1322:  CLRF   x95
1324:  MOVLW  7D
1326:  MOVWF  x94
1328:  RCALL  1152
132A:  BC    132E
132C:  BNZ   1338
....................    { 
....................       change_lights(0b00010010); 
132E:  CLRF   x91
1330:  MOVLW  12
1332:  MOVWF  x90
1334:  RCALL  11C8
....................    }  
....................     
....................    else if (rat <= 0.5) 
1336:  BRA    13DE
1338:  MOVFF  8F,93
133C:  MOVFF  8E,92
1340:  MOVFF  8D,91
1344:  MOVFF  8C,90
1348:  CLRF   x97
134A:  CLRF   x96
134C:  CLRF   x95
134E:  MOVLW  7E
1350:  MOVWF  x94
1352:  RCALL  1152
1354:  BC    1358
1356:  BNZ   1362
....................    { 
....................       change_lights(0b00010000); 
1358:  CLRF   x91
135A:  MOVLW  10
135C:  MOVWF  x90
135E:  RCALL  11C8
....................    }  
....................     
....................    else if (rat <= 0.75) 
1360:  BRA    13DE
1362:  MOVFF  8F,93
1366:  MOVFF  8E,92
136A:  MOVFF  8D,91
136E:  MOVFF  8C,90
1372:  CLRF   x97
1374:  CLRF   x96
1376:  MOVLW  40
1378:  MOVWF  x95
137A:  MOVLW  7E
137C:  MOVWF  x94
137E:  RCALL  1152
1380:  BC    1384
1382:  BNZ   138E
....................    { 
....................       change_lights(0b00110000); 
1384:  CLRF   x91
1386:  MOVLW  30
1388:  MOVWF  x90
138A:  RCALL  11C8
....................    }  
....................     
....................    else if (rat < 1.0) 
138C:  BRA    13DE
138E:  MOVFF  8F,93
1392:  MOVFF  8E,92
1396:  MOVFF  8D,91
139A:  MOVFF  8C,90
139E:  CLRF   x97
13A0:  CLRF   x96
13A2:  CLRF   x95
13A4:  MOVLW  7F
13A6:  MOVWF  x94
13A8:  RCALL  1152
13AA:  BNC   13B6
....................    { 
....................       change_lights(0b00100100); 
13AC:  CLRF   x91
13AE:  MOVLW  24
13B0:  MOVWF  x90
13B2:  RCALL  11C8
....................    }  
....................     
....................    else if (rat >= 1.0) 
13B4:  BRA    13DE
13B6:  CLRF   x93
13B8:  CLRF   x92
13BA:  CLRF   x91
13BC:  MOVLW  7F
13BE:  MOVWF  x90
13C0:  MOVFF  8F,97
13C4:  MOVFF  8E,96
13C8:  MOVFF  8D,95
13CC:  MOVFF  8C,94
13D0:  RCALL  1152
13D2:  BC    13D6
13D4:  BNZ   13DE
....................    { 
....................       change_lights(0b00100000); 
13D6:  CLRF   x91
13D8:  MOVLW  20
13DA:  MOVWF  x90
13DC:  RCALL  11C8
....................    }  
.................... } 
13DE:  RETLW  00
....................  
.................... void change_lights(int16 process) 
.................... { 
....................    // change the lights based on process argument 
....................    // follows the key shown below: 
....................    // 0b X X G Y R Gf Yf Rf 
....................    // where X is don't care, G is green on/off, Y is yellow on/off, Gf is Green flashing enabled/disabled, etc... 
....................     
....................    output_low(GREEN); 
*
11C8:  BCF    F92.0
11CA:  BCF    F89.0
....................    output_low(YELLOW); 
11CC:  BCF    F94.2
11CE:  BCF    F8B.2
....................    output_low(RED); 
11D0:  BCF    F92.1
11D2:  BCF    F89.1
....................    green_countdown = 0; 
11D4:  CLRF   x77
....................    yellow_countdown = 0; 
11D6:  CLRF   x78
....................    red_countdown = 0; 
11D8:  CLRF   x79
....................     
....................        
....................    if ((process&0b00100000) > 0) 
11DA:  MOVF   x90,W
11DC:  ANDLW  20
11DE:  MOVWF  x92
11E0:  CLRF   x93
11E2:  MOVF   x92,F
11E4:  BNZ   11EA
11E6:  MOVF   x93,F
11E8:  BZ    11EE
....................       output_high(GREEN); 
11EA:  BCF    F92.0
11EC:  BSF    F89.0
....................        
....................    if ((process&0b00010000) > 0) 
11EE:  MOVF   x90,W
11F0:  ANDLW  10
11F2:  MOVWF  x92
11F4:  CLRF   x93
11F6:  MOVF   x92,F
11F8:  BNZ   11FE
11FA:  MOVF   x93,F
11FC:  BZ    1202
....................       output_high(YELLOW); 
11FE:  BCF    F94.2
1200:  BSF    F8B.2
....................        
....................    if ((process&0b00001000) > 0) 
1202:  MOVF   x90,W
1204:  ANDLW  08
1206:  MOVWF  x92
1208:  CLRF   x93
120A:  MOVF   x92,F
120C:  BNZ   1212
120E:  MOVF   x93,F
1210:  BZ    1216
....................       output_high(RED); 
1212:  BCF    F92.1
1214:  BSF    F89.1
....................        
....................    if ((process&0b00000100) > 0) 
1216:  MOVF   x90,W
1218:  ANDLW  04
121A:  MOVWF  x92
121C:  CLRF   x93
121E:  MOVF   x92,F
1220:  BNZ   1226
1222:  MOVF   x93,F
1224:  BZ    122A
....................       green_countdown = 1; 
1226:  MOVLW  01
1228:  MOVWF  x77
....................        
....................    if ((process&0b00000010) > 0) 
122A:  MOVF   x90,W
122C:  ANDLW  02
122E:  MOVWF  x92
1230:  CLRF   x93
1232:  MOVF   x92,F
1234:  BNZ   123A
1236:  MOVF   x93,F
1238:  BZ    123E
....................       yellow_countdown = 1; 
123A:  MOVLW  01
123C:  MOVWF  x78
....................        
....................    if ((process&0b00000001) > 0) 
123E:  MOVF   x90,W
1240:  ANDLW  01
1242:  MOVWF  x92
1244:  CLRF   x93
1246:  MOVF   x92,F
1248:  BNZ   124E
124A:  MOVF   x93,F
124C:  BZ    1252
....................       red_countdown = 1; 
124E:  MOVLW  01
1250:  MOVWF  x79
....................        
.................... } 
1252:  RETLW  00
....................  
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
....................   // control the flashing of lights if currently enabled 
....................    
....................   output_toggle(pin_c1); 
*
0530:  BCF    F94.1
0532:  BTG    F8B.1
....................    if(green_countdown > 0) 
0534:  MOVF   x77,F
0536:  BZ    0544
....................    { 
....................       output_toggle(GREEN); 
0538:  BCF    F92.0
053A:  BTG    F89.0
....................        
....................        
....................       if(green_countdown == 0) 
053C:  MOVF   x77,F
053E:  BNZ   0544
....................       { 
....................          output_high(GREEN); 
0540:  BCF    F92.0
0542:  BSF    F89.0
....................       } 
....................    } 
....................     
....................    if(yellow_countdown > 0) 
0544:  MOVF   x78,F
0546:  BZ    0554
....................    { 
....................       output_toggle(YELLOW); 
0548:  BCF    F94.2
054A:  BTG    F8B.2
....................        
....................        
....................       if(yellow_countdown == 0) 
054C:  MOVF   x78,F
054E:  BNZ   0554
....................       { 
....................          output_high(YELLOW); 
0550:  BCF    F94.2
0552:  BSF    F8B.2
....................       } 
....................    } 
....................     
....................    if(red_countdown > 0) 
0554:  MOVF   x79,F
0556:  BZ    0564
....................    { 
....................       output_toggle(RED); 
0558:  BCF    F92.1
055A:  BTG    F89.1
....................        
....................        
....................       if(red_countdown == 0) 
055C:  MOVF   x79,F
055E:  BNZ   0564
....................       { 
....................          output_high(RED); 
0560:  BCF    F92.1
0562:  BSF    F89.1
....................       } 
....................    } 
....................     
.................... } 
0564:  BCF    FF2.2
0566:  GOTO   007C

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 0E1F   BROWNOUT WDT128 NOWDT BORV21 NOPUT
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0095   STVREN NODEBUG LVP BBSIZ2K NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
